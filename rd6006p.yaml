esphome:
  name: "esp8266-rd6006p"
  comment: "Controls RD6006p PSU over MODBUS"
  name_add_mac_suffix: false
  project:
    name: "mdbind.rd6006p-controller"
    version: "1.0.0"

esp8266:
  board: esp12e

# Enable logging
logger:
  #level: DEBUG
  # Disable logging via UART, since we're using this for modbus communication
  baud_rate: 0

# Enable status LED
status_led:
  pin:
    number: GPIO2
    inverted: true
    
# Enable Home Assistant API
api:
  reboot_timeout: 1h

ota:
  password: ""

web_server:
  port: 80

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
# Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Rd6006 Fallback Hotspot"
    password: "M7C2NAsAdPEU"

captive_portal:

uart:
  id: mod_bus
  tx_pin: GPIO1
  rx_pin: GPIO3
  baud_rate: 115200
  data_bits: 8
  stop_bits: 1
  parity: none

modbus:
 id: modbus1

modbus_controller:
  - id: powersupply
    ## This address should be set to the value in the RD6006 config menu
    address: 0x01
    modbus_id: modbus1
    setup_priority: -10
    update_interval: 5s

sensor:
  - platform: modbus_controller
    modbus_controller_id: powersupply
    register_type: holding
    address: 10
    name: "Output voltage"
    device_class: voltage
    unit_of_measurement: "V"
    icon: "mdi:sine-wave"
    value_type: U_WORD
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: powersupply
    register_type: holding
    address: 11
    name: "Output current"
    device_class: current
    unit_of_measurement: "A"
    icon: "mdi:current-dc"
    value_type: U_WORD
    accuracy_decimals: 4
    filters:
      - multiply: 0.0001

  - platform: modbus_controller
    modbus_controller_id: powersupply
    register_type: holding
    address: 33
    name: "Battery voltage"
    device_class: voltage
    unit_of_measurement: "V"
    icon: "mdi:battery-outline"
    value_type: U_WORD
    accuracy_decimals: 3
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    name: "Model Number"
    entity_category: diagnostic
    modbus_controller_id: powersupply
    address: 0
    skip_updates: 10
    unit_of_measurement: ""
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0
  
  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 3
    name: "Firmware version"
    entity_category: diagnostic
    unit_of_measurement: ""
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
  
  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 14
    name: "Input voltage"
    device_class: voltage
    unit_of_measurement: "V"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01
  
  - platform: modbus_controller
    name: "Temperature internal"
    modbus_controller_id: powersupply
    device_class: temperature
    unit_of_measurement: "°C"
    register_type: holding
    address: 4
    value_type: S_DWORD
    filters:
      - multiply: 1
    
  - platform: modbus_controller
    name: "Temperature external"
    modbus_controller_id: powersupply
    device_class: temperature
    unit_of_measurement: "°C"
    register_type: holding
    address: 34
    value_type: S_DWORD
    filters:
      - multiply: 1
    
  - platform: uptime
    name: "RD6006 Uptime"
  
  - platform: wifi_signal
    name: "RD6006 Wi-Fi Signal"
    update_interval: 60s

  - platform: modbus_controller
    name: "Year"
    id: date_year
    modbus_controller_id: powersupply
    entity_category: diagnostic
    register_type: holding
    address: 48
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    name: "Month"
    id: date_month
    modbus_controller_id: powersupply
    entity_category: diagnostic
    register_type: holding
    address: 49
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    name: "Day"
    id: date_day
    modbus_controller_id: powersupply
    entity_category: diagnostic
    register_type: holding
    address: 50
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    name: "Hour"
    id: date_hour
    modbus_controller_id: powersupply
    entity_category: diagnostic
    register_type: holding
    address: 51
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    name: "Minute"
    id: date_minute
    modbus_controller_id: powersupply
    entity_category: diagnostic
    register_type: holding
    address: 52
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    name: "Second"
    id: date_second
    modbus_controller_id: powersupply
    entity_category: diagnostic
    register_type: holding
    address: 53
    value_type: U_WORD
    internal: true

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "RD6006 IP Address"
    ssid:
      name: "RD6006 Wi-Fi SSID"
    bssid:
      name: "RD6006 Wi-Fi BSSID"
  - platform: version
    name: "RD6006 Version"
    hide_timestamp: true

  - platform: template
    name: "Date & Time"
    entity_category: diagnostic
    update_interval: 10s
    lambda: |-
      int year = id(date_year).state;
      int month = id(date_month).state;
      int day = id(date_day).state;
      int hour = id(date_hour).state;
      int minute = id(date_minute).state;
      int second = id(date_second).state;
      std::string year_str = to_string(year);
      std::string month_str = month < 10 ? "0" + to_string(month) : to_string(month);
      std::string day_str = day < 10 ? "0" + to_string(day) : to_string(day);
      std::string hour_str = hour < 10 ? "0" + to_string(hour) : to_string(hour);
      std::string minute_str = minute < 10 ? "0" + to_string(minute) : to_string(minute);
      std::string second_str = second < 10 ? "0" + to_string(second) : to_string(second);
      return day_str + "/" + month_str + "/" + year_str + " " + hour_str + ":" + minute_str + ":" + second_str;
    icon: mdi:calendar


binary_sensor:
  - platform: modbus_controller
    modbus_controller_id: powersupply
    register_type: holding
    name: "Keypad lock"
    entity_category: diagnostic
    device_class: lock
    address: 15
    bitmask: 0x1

  - platform: modbus_controller
    modbus_controller_id: powersupply
    register_type: holding
    name: "Battery mode"
    entity_category: diagnostic
    icon: "mdi:battery-charging-50"
    address: 32
    bitmask: 0x1

  
number:
  - platform: modbus_controller
    name: "Backlight"
    modbus_controller_id: powersupply
    entity_category: config
    address: 72
    icon: "mdi:lightbulb"
    value_type: U_WORD
    min_value: 0
    max_value: 5

  - platform: modbus_controller
    modbus_controller_id: powersupply
    id: output_voltage
    name: "Set voltage"
    unit_of_measurement: "V"
    address: 8
    entity_category: config
    icon: "mdi:sine-wave"
    value_type: U_WORD
    min_value: 0
    max_value: 61
    step: 0.001
    multiply: 1000
  
  - platform: modbus_controller
    modbus_controller_id: powersupply
    name: "Set current"
    unit_of_measurement: "A"
    address: 9
    entity_category: config
    icon: "mdi:current-dc"
    value_type: U_WORD
    min_value: 0
    max_value: 6.1
    step: 0.0001
    multiply: 10000

  - platform: modbus_controller
    modbus_controller_id: powersupply
    id: ovp
    name: "Over voltage protection"
    unit_of_measurement: "V"
    address: 82
    entity_category: config
    icon: "mdi:sine-wave"
    value_type: U_WORD
    min_value: 0
    max_value: 61
    step: 0.001
    multiply: 1000

  - platform: modbus_controller
    modbus_controller_id: powersupply
    id: ocp
    name: "Over current protection"
    unit_of_measurement: "A"
    address: 83
    entity_category: config
    icon: "mdi:current-dc"
    value_type: U_WORD
    min_value: 0
    max_value: 6.1
    step: 0.0001
    multiply: 10000

  - platform: template
    id: wave_min
    name: "Wave min"
    icon: "mdi:triangle-wave"
    unit_of_measurement: "V"
    optimistic: true
    initial_value: 0
    min_value: 0
    max_value: 61
    step: 0.001

  - platform: template
    id: wave_step
    name: "Wave step"
    icon: "mdi:triangle-wave"
    optimistic: true
    initial_value: 0.1
    min_value: 0.001
    max_value: 1
    step: 0.001

  - platform: template
    id: wave_delay
    name: "Wave delay"
    unit_of_measurement: "ms"
    icon: "mdi:clock-time-eight-outline"
    optimistic: true
    initial_value: 500
    min_value: 100
    max_value: 10000
    step: 10

  - platform: template
    id: sine_seed
    name: "test_seed"
    optimistic: true
    initial_value: 0
    min_value: 0
    max_value: 6
    step: 0.1
    internal: true

switch:
  - platform: modbus_controller
    modbus_controller_id: powersupply
    name: "Output"
    address: 18
    register_type: holding
    bitmask: 0x1
    entity_category: config
    on_turn_off:
      - script.stop: triangle_up
      - script.stop: triangle_down
      - script.stop: sine_start

  - platform: template
    name: "Start Triangle wave"
    icon: "mdi:triangle-wave"
    turn_on_action:
      - logger.log: "Triangle wave started"
      - script.execute: triangle_up

  - platform: template
    name: "Start Sine wave"
    icon: "mdi:sine-wave"
    turn_on_action:
      - logger.log: "Sine wave started"
      - script.execute: sine_start

  - platform: template
    name: "Stop wave"
    icon: "mdi:close-octagon-outline"
    turn_on_action:
      - script.stop: triangle_up
      - script.stop: triangle_down
      - script.stop: sine_start

script:
  - id: triangle_up
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
              auto now = id(output_voltage).state;
              auto max = id(ovp).state;
              auto step = id(wave_step).state;
              return (now+step) < max;
          then:
            - lambda: |-
                auto now = id(output_voltage).state;
                auto step = id(wave_step).state;
                auto call = id(output_voltage).make_call();
                call.set_value(now+step);
                call.perform();
            - delay: !lambda "return int(id(wave_delay).state);"
            - script.execute: triangle_up
          else:
            - script.execute: triangle_down

  - id: triangle_down
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
              auto now = id(output_voltage).state;
              auto step = id(wave_step).state;
              return (now-step) > id(wave_min).state;
          then:
            - lambda: |-
                auto now = id(output_voltage).state;
                auto step = id(wave_step).state;
                auto call = id(output_voltage).make_call();
                call.set_value(now-step);
                call.perform();
            - delay: !lambda "return int(id(wave_delay).state);"
            - script.execute: triangle_down
          else:
            - script.execute: triangle_up

  - id: sine_start
    mode: restart
    then:
      - lambda: |-
          auto min = id(wave_min).state;
          auto max = id(ovp).state;
          auto delta = max - min;
          auto seed = id(sine_seed).state;
          auto amplitude = delta / 2.0;
          auto offset = min + amplitude;
          auto step = amplitude * sin(seed) + offset;
          auto call = id(output_voltage).make_call();
          call.set_value(step);
          call.perform();
      - number.increment:
          id: sine_seed
          cycle: true
      - delay: !lambda "return int(id(wave_delay).state);"
      - script.execute: sine_start